# 힙 (Heap)

## 1. 힙 (Heap)이란?

- 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 **완전 이진 트리 (Complete Binary Tree)**
    
    <aside>
    💡 완전 이진 트리
    - 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리
    
    </aside>
    
- 힙을 사용하는 이유
    - 배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n)이 걸림
    - **이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, O(logn)이 걸림**
    - 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야하는 자료구조 및 알고리즘 구현등에 활용
- 반정렬 상태 (느슨한 정렬 상태) 를 유지
    - 부모노드 키 값이 자식 노드 키 값보다 항상 큼
- 힙 트리에서는 중복된 값을 허용 (이진 탐색트리에서는 허용 하지 않음.)

## 2. 힙(Heap) 구조

- 힙은
    - 최대값을 구하기 위한 구조 **(최대 힙, Max Heap)**
        - 부모 노드 키 > = 자식 노드 키 , 완전이진트리
    - 최소값을 구하기 위한 구조 **(최소 힙, Min Heap)**
        - 부모 노드 키 < = 자식 노드 키, 완전이진트리
- 힙은 다름과 같이 두 가지 조건을 가지고 있는 자료구조
    1. 각 노드의 값은 해당 노드의 자식노드가 가진 값보다 크거나 같다.(최대 힙의 경우)
        - 최소 합의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작음
    2. 완전 이진 트리 형태를 가짐
    

### 힙에서의 부모 노드와 자식 노드의 관계

```
- 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
- 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
- 부모의 인덱스 = (자식의 인덱스) / 2
```

### 힙과 이진 탐색 트리의 공통점과 차이점

```
- 공통점 : 모두 이진 트리임
- 차이점 :
    - 힙은 각 노드의 값이 자식 노드보다 크거나 같음 (Max Heap의 경우)
    - 이전 탐색 트리는( 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드) 순으로 값이 큼
    - 힙은 작은값이 왼쪽, 큰 값이 오른쪽인 조건은 없음
        따라서, 힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있음
```

## 3. 힙 (Heap)동작

- 기본적으로 배열에 저장
- 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은  사용하지 않음
- 특정 위치의 노드는 새로운 노드가 추가되어도 변하지 않음

### 힙  삽입

- 힙은 완전 이진 트리이므로, 삽힙할 노드는 기본적으로 왼쪽 최하단부 노드부터 채워지는 형태로 삽입

```
최대 힙(Max Heap) 일 경우
1. 힙에 새로운 요소가 입력되면, 힙의 마지막 노드에 삽입
2. 새로운 노드가 부모 노드보드 값이 클 경우, 위치를 바꿔줌 (swap)
```

```java
public static void insert(int x) {
        heap.add(x);

        int dep = heap.size() - 1;

        while (dep > 1 && heap.get(dep / 2) < heap.get(dep)) {
            int temp = heap.get(dep / 2);
            heap.set(dep / 2, heap.get(dep));
            heap.set(dep, temp);

            dep = dep / 2;
        }
    }
```

### 힙 삭제

- **보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적**
    - 힙의 용도는 최대값 또는 최소값을 root노드에 놓고 바로 꺼낼 수 있는 구조

```
최대 힙(Max Heap) 일 경우 
  1. 상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드(가장 마지막에 추가한 노드)를 root노드로 이동
  2. root 노드의 값이 child node 보다 작을 경우, root 노드의 child node 중 가장 큰 값을 가진 노드 위치를 바꿔주는 작업을 반복함 (swap)
```

```java
public static void delete(){

        if(heap.size()-1 <1){
            return;
        }

        int deleted = heap.get(1);

        heap.set(1, heap.get(heap.size()-1));
        heap.remove(heap.size()-1);

        int pos = 1;

        while ((pos*2)<heap.size()){
            int max = heap.get(pos * 2);
            int maxPos = pos *2;
            if(((pos * 2 + 1) < heap.size()) &&
                    max < heap.get(pos * 2 + 1)) {
                max = heap.get(pos * 2 + 1);
                maxPos = pos * 2 + 1;
            }
            if(heap.get(pos) > max) {
                break;
            }

            int temp = heap.get(pos);
            heap.set(pos, heap.get(maxPos));
            heap.set(maxPos, temp);
            pos = maxPos;
        }

    }
```

## 4. 힙(Heap) 시간 복잡도

- depth 를 h 라고 표기한다면,
- n 개의 노드를 가지는 heap 에 데이터 삽입 또는 삭제시, 최악의 경우 root노드에서 leaf 노드까지 비교해야 하므로
h = log₂n에 가까우므로, 시간 복잡도는 O(logn)
    - 참고 : 빅오 표기법에서 logn에서의 log의 밑은 10이 아니라 2
    - 한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미